<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Realistic Open World</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.2rem; pointer-events: none; transition: opacity 0.5s; }
        
        /* UIレイヤー */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; }
        
        /* ジョイスティック領域 (左下) */
        #zone_joystick { 
            position: absolute; bottom: 20px; left: 20px; 
            width: 150px; height: 150px; 
            pointer-events: auto; /* ここだけタッチ可能 */
        }
        
        /* 視点操作領域 (右側全体) */
        #zone_look {
            position: absolute; top: 0; right: 0; bottom: 0; width: 50%;
            pointer-events: auto;
        }

        .guide { position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.7); text-shadow: 1px 1px 2px black; pointer-events: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/simplex-noise.js"></script>
</head>
<body>

<div id="loading">Loading Nature Assets...</div>


<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    // --- 設定 ---
    const CONFIG = {
        speed: 5.0,
        turnSpeed: 0.002,
        treeCount: 40,
        worldSize: 200
    };

    // グローバル変数
    let scene, camera, renderer, clock;
    let playerObj; // プレイヤーの体（カメラの親）
    let ground; // 地形メッシュ
    const mixers = []; // アニメーション用（今回は未使用だが拡張用）

    // 入力状態
    const touchState = {
        move: { id: -1, x: 0, y: 0, dx: 0, dy: 0 },
        look: { id: -1, x: 0, y: 0, dx: 0, dy: 0 }
    };
    
    init();

    function init() {
        // 1. シーンとカメラ
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xe0f7fa, 0.015); // 遠くを霞ませる（処理落ち隠し＆雰囲気）

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        
        // プレイヤーコンテナ（これを移動させる）
        playerObj = new THREE.Group();
        playerObj.position.set(0, 0, 0);
        playerObj.add(camera);
        camera.position.set(0, 1.7, 0); // 目の高さ
        scene.add(playerObj);

        // 2. レンダラー
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // スマホの負荷軽減
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 映画のような色調
        renderer.toneMappingExposure = 1.0;
        renderer.shadowMap.enabled = true; // 影を有効化
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // 3. 水面を追加
        const waterGeometry = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            transparent: true,
            opacity: 0.7,
            roughness: 0.1,
            metalness: 0.8
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0; // 水位
        scene.add(water);

        // 4. アセット読み込み開始
        loadEnvironment();
        loadTerrain();
        loadAssets(); // 木など
        setupControls(); // 操作系

        animate();
    }

    // --- 環境（空と光）: HDRIを使用 ---
    function loadEnvironment() {
        const rgbeLoader = new RGBELoader();
        // Poly HavenのパブリックドメインHDRI
        rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/kloofendal_48d_partly_cloudy_puresky_1k.hdr', function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture; // モデルへの映り込み用

            // 太陽光（影用）
            const sunLight = new THREE.DirectionalLight(0xffffee, 1.5);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
        });
    }

    // --- 地形 ---
    function loadTerrain() {
        const simplex = new SimplexNoise();
        const geometry = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 256, 256);
        
        // 頂点の高さを計算し、色を割り当てる
        const vertices = geometry.attributes.position;
        const colors = [];
        const color = new THREE.Color();

        // バイオームのカラーストップ
        const biomeColors = {
            sand: new THREE.Color(0xc2b280),
            grass: new THREE.Color(0x559020),
            rock: new THREE.Color(0x808080),
            snow: new THREE.Color(0xffffff)
        };

        for (let i = 0; i < vertices.count; i++) {
            const x = vertices.getX(i);
            const y = vertices.getY(i);

            // Simplex Noise を使って自然な地形を生成
            const noise1 = simplex.noise2D(x / 150, y / 150) * 10;
            const noise2 = simplex.noise2D(x / 40, y / 40) * 3;
            const noise3 = simplex.noise2D(x / 10, y / 10) * 1;
            const height = noise1 + noise2 + noise3;
            vertices.setZ(i, height);

            // 高さに基づいて色を決定
            if (height < 1) {
                color.copy(biomeColors.sand);
            } else if (height < 5) {
                // 砂と草を滑らかに混ぜる
                const factor = (height - 1) / (5 - 1);
                color.copy(biomeColors.sand).lerp(biomeColors.grass, factor);
            } else if (height < 10) {
                 // 草と岩を滑らかに混ぜる
                const factor = (height - 5) / (10 - 5);
                color.copy(biomeColors.grass).lerp(biomeColors.rock, factor);
            } else if (height < 13) {
                // 岩と雪を滑らかに混ぜる
                const factor = (height - 10) / (13 - 10);
                color.copy(biomeColors.rock).lerp(biomeColors.snow, factor);
            } else {
                color.copy(biomeColors.snow);
            }
            colors.push(color.r, color.g, color.b);
        }
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        geometry.computeVertexNormals(); // 法線を再計算して、光の当たり方を正しくする

        // テクスチャではなく、頂点の色で地形を表現する
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true, 
            roughness: 0.9,
            metalness: 0.1
        });

        ground = new THREE.Mesh(geometry, material);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
    }

    // --- 外部モデル（木） ---
    function loadAssets() {
        const loader = new GLTFLoader();
        const raycaster = new THREE.Raycaster();
        const origin = new THREE.Vector3(0, 50, 0); // レイの開始点 (十分高い位置)
        const direction = new THREE.Vector3(0, -1, 0); // レイの方向 (真下)

        loader.load('https://raw.githubusercontent.com/discoverthreejs/discover-threejs-book/master/public/models/low_poly_tree.glb', (gltf) => {
            const treeModel = gltf.scene;
            treeModel.traverse((c) => {
                if (c.isMesh) {
                    c.castShadow = true;
                }
            });

            let treesPlaced = 0;
            while (treesPlaced < CONFIG.treeCount) {
                const x = (Math.random() - 0.5) * CONFIG.worldSize;
                const z = (Math.random() - 0.5) * CONFIG.worldSize;
                origin.set(x, 50, z);
                raycaster.set(origin, direction);

                const intersects = raycaster.intersectObject(ground);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const y = hit.point.y;
                    const normal = hit.face.normal;

                    // 水中(y<0)や急な崖(法線のy成分が小さい)には配置しない
                    if (y > 0.5 && normal.y > 0.9) {
                        const tree = treeModel.clone();
                        const s = 1.5 + Math.random() * 2;
                        tree.scale.set(s, s, s);
                        tree.position.set(x, y, z);
                        tree.rotation.y = Math.random() * Math.PI * 2;
                        scene.add(tree);
                        treesPlaced++;
                    }
                }
            }
            document.getElementById('loading').style.display = 'none';
        }, undefined, (error) => {
            console.error('Model load error, using fallback:', error);
            createFallbackTrees();
            document.getElementById('loading').style.display = 'none';
        });
    }

    function createFallbackTrees() {
        const geo = new THREE.CylinderGeometry(0, 1, 4, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        for(let i=0; i<CONFIG.treeCount; i++){
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set((Math.random()-0.5)*100, 2, (Math.random()-0.5)*100);
            scene.add(mesh);
        }
    }

    // --- 操作系 (タッチのみ) ---
    function setupControls() {
        renderer.domElement.addEventListener('touchstart', handleTouchStart);
        renderer.domElement.addEventListener('touchmove', handleTouchMove);
        renderer.domElement.addEventListener('touchend', handleTouchEnd);
        renderer.domElement.addEventListener('touchcancel', handleTouchEnd);
    }

    function handleTouchStart(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            if (touch.clientX < window.innerWidth / 2 && touchState.move.id === -1) {
                // 左半分: 移動
                touchState.move.id = touch.identifier;
                touchState.move.x = touch.clientX;
                touchState.move.y = touch.clientY;
            } else if (touch.clientX >= window.innerWidth / 2 && touchState.look.id === -1) {
                // 右半分: 視点
                touchState.look.id = touch.identifier;
                touchState.look.x = touch.clientX;
                touchState.look.y = touch.clientY;
            }
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            if (touch.identifier === touchState.move.id) {
                touchState.move.dx = (touch.clientX - touchState.move.x) / 50;
                touchState.move.dy = (touch.clientY - touchState.move.y) / 50;
            } else if (touch.identifier === touchState.look.id) {
                touchState.look.dx = (touch.clientX - touchState.look.x) * 0.1;
                touchState.look.dy = (touch.clientY - touchState.look.y) * 0.1;
                touchState.look.x = touch.clientX;
                touchState.look.y = touch.clientY;
            }
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            if (touch.identifier === touchState.move.id) {
                touchState.move.id = -1;
                touchState.move.dx = 0;
                touchState.move.dy = 0;
            } else if (touch.identifier === touchState.look.id) {
                touchState.look.id = -1;
                touchState.look.dx = 0;
                touchState.look.dy = 0;
            }
        }
    }

    // --- メインループ ---
    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        
        // --- 視点更新 ---
        if (touchState.look.id !== -1) {
            playerObj.rotation.y -= touchState.look.dx * CONFIG.turnSpeed;
            camera.rotation.x -= touchState.look.dy * CONFIG.turnSpeed;
            camera.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, camera.rotation.x));
            // dx, dyは消費したのでリセット
            touchState.look.dx = 0;
            touchState.look.dy = 0;
        }

        // --- 移動更新 ---
        const moveForward = -touchState.move.dy;
        const moveRight = touchState.move.dx;

        if (Math.abs(moveForward) > 0.1 || Math.abs(moveRight) > 0.1) {
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerObj.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerObj.quaternion);
            
            direction.addScaledVector(forward, moveForward);
            direction.addScaledVector(right, moveRight);
            direction.normalize();

            playerObj.position.addScaledVector(direction, CONFIG.speed * delta);
        }

        // --- 地形当たり判定 ---
        const raycaster = new THREE.Raycaster(playerObj.position.clone().setY(50), new THREE.Vector3(0, -1, 0));
        const intersects = raycaster.intersectObject(ground);
        if (intersects.length > 0) {
            const groundHeight = intersects[0].point.y;
            const targetY = groundHeight + 1.7; // 目の高さ
            // スムーズにY座標を更新
            playerObj.position.y = THREE.MathUtils.lerp(playerObj.position.y, targetY, 0.2);
        }

        renderer.render(scene, camera);
    }

    // リサイズ対応
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
