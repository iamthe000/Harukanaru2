<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>High Speed Open World (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87ceeb; font-family: sans-serif; touch-action: none; }
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #222; color: white; display: flex; align-items: center; justifyContent: center; z-index: 100; transition: opacity 0.8s; pointer-events: none; }
        .guide { position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 4px black; pointer-events: none; z-index: 5; font-size: 14px; }
        #zone_joystick { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.0/dist/simplex-noise.min.js"></script>
</head>
<body>

<div id="loading">
    <div style="text-align:center;">
        <div style="font-size:24px; margin-bottom:10px;">GENERATING WORLD...</div>
        <div style="font-size:12px; opacity:0.7;">High Speed & Mountain Update</div>
    </div>
</div>

<div class="guide">
    <b>LEFT:</b> Move Fast (Slide)<br>
    <b>RIGHT:</b> Look Around
</div>
<div id="zone_joystick"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    // --- CONFIG ---
    const CONFIG = {
        speed: 35.0,        // さらに高速化
        turnSpeed: 0.003,
        treeCount: 50,
        worldSize: 600
    };

    let scene, camera, renderer, clock, playerObj, ground;
    const touchState = {
        move: { id: -1, x: 0, y: 0, dx: 0, dy: 0 },
        look: { id: -1, x: 0, y: 0, dx: 0, dy: 0 }
    };

    // 万が一のための強制ローディング解除
    setTimeout(hideLoading, 5000);

    init();

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xd0e0f0, 0.004);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1500);
        playerObj = new THREE.Group();
        playerObj.position.set(0, 50, 0); 
        playerObj.add(camera);
        camera.position.set(0, 1.8, 0); 
        scene.add(playerObj);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // 1. 環境光
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        // 2. 水面（境界をはっきりさせるため不透明度調整）
        const water = new THREE.Mesh(
            new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize),
            new THREE.MeshStandardMaterial({ color: 0x003366, transparent: true, opacity: 0.9, roughness: 0.1, metalness: 0.5 })
        );
        water.rotation.x = -Math.PI / 2;
        water.position.y = -1.5;
        scene.add(water);

        loadTerrain();
        loadEnvironment();
        loadAssets();
        setupControls();
        animate();
    }

    function loadTerrain() {
        // SimplexNoiseの初期化（エラー回避策付き）
        let simplex;
        try {
            simplex = new SimplexNoise();
        } catch (e) {
            console.warn("SimplexNoise not found, using fallback.");
            simplex = { noise2D: (x, y) => Math.sin(x/10) * Math.cos(y/10) };
        }

        const segments = 128;
        const geo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, segments, segments);
        const pos = geo.attributes.position;
        const colors = [];
        
        const c_sand = new THREE.Color(0xe3c08d);
        const c_grass = new THREE.Color(0x3a7d20);
        const c_rock = new THREE.Color(0x555555);
        const c_snow = new THREE.Color(0xffffff);

        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const y = pos.getY(i);

            // 山・岩・平地のノイズ計算
            let h = 0;
            // 巨大な山脈
            h += Math.pow(Math.abs(simplex.noise2D(x/400, y/400)), 2) * 80;
            // 中規模の岩山
            h += simplex.noise2D(x/100, y/100) * 15;
            // 細かな凹凸
            h += simplex.noise2D(x/30, y/30) * 3;

            pos.setZ(i, h);

            // 色付け（バイオームの差をはっきりさせる）
            let finalCol = new THREE.Color();
            if (h < 2) finalCol.copy(c_sand);
            else if (h < 25) finalCol.copy(c_grass);
            else if (h < 55) {
                const f = (h - 25) / 30;
                finalCol.copy(c_grass).lerp(c_rock, f);
            } else {
                const f = Math.min(1, (h - 55) / 10);
                finalCol.copy(c_rock).lerp(c_snow, f);
            }
            colors.push(finalCol.r, finalCol.g, finalCol.b);
        }
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 });
        ground = new THREE.Mesh(geo, mat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        ground.updateMatrixWorld();
    }

    function loadEnvironment() {
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(100, 200, 100);
        scene.add(sun);

        const rgbe = new RGBELoader();
        // HDRの読み込みに失敗しても進行するようにする
        rgbe.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/kloofendal_48d_partly_cloudy_puresky_1k.hdr', (tex) => {
            tex.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = tex;
        }, undefined, (err) => console.log("HDR load skipped."));
    }

    function loadAssets() {
        const loader = new GLTFLoader();
        const url = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/LowPolyTree.glb'; // URL変更

        loader.load(url, (gltf) => {
            placeTrees(gltf.scene);
            hideLoading();
        }, undefined, () => {
            console.warn("Tree model failed. Using fallback.");
            const fallback = new THREE.Mesh(new THREE.ConeGeometry(1, 4), new THREE.MeshStandardMaterial({color: 0x1a4a1a}));
            placeTrees(fallback);
            hideLoading();
        });
    }

    function placeTrees(model) {
        const ray = new THREE.Raycaster();
        let count = 0;
        for (let i = 0; i < 300 && count < CONFIG.treeCount; i++) {
            const x = (Math.random() - 0.5) * CONFIG.worldSize * 0.7;
            const z = (Math.random() - 0.5) * CONFIG.worldSize * 0.7;
            ray.set(new THREE.Vector3(x, 200, z), new THREE.Vector3(0, -1, 0));
            const hit = ray.intersectObject(ground);
            if (hit.length > 0) {
                const p = hit[0].point;
                // 草地(標高3~20)かつ平坦な場所
                if (p.y > 3 && p.y < 20 && hit[0].face.normal.y > 0.9) {
                    const t = model.clone();
                    t.position.copy(p);
                    t.scale.setScalar(1.5 + Math.random() * 2);
                    scene.add(t);
                    count++;
                }
            }
        }
    }

    function hideLoading() {
        const el = document.getElementById('loading');
        if (el) el.style.opacity = '0';
    }

    function setupControls() {
        const cv = renderer.domElement;
        cv.addEventListener('touchstart', (e) => {
            for (const t of e.changedTouches) {
                if (t.clientX < window.innerWidth / 2) {
                    touchState.move.id = t.identifier;
                    touchState.move.x = t.clientX; touchState.move.y = t.clientY;
                } else {
                    touchState.look.id = t.identifier;
                    touchState.look.x = t.clientX; touchState.look.y = t.clientY;
                }
            }
        });

        cv.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (const t of e.changedTouches) {
                if (t.identifier === touchState.move.id) {
                    touchState.move.dx = (t.clientX - touchState.move.x) / 30;
                    touchState.move.dy = (t.clientY - touchState.move.y) / 30;
                } else if (t.identifier === touchState.look.id) {
                    touchState.look.dx = t.clientX - touchState.look.x;
                    touchState.look.dy = t.clientY - touchState.look.y;
                    touchState.look.x = t.clientX; touchState.look.y = t.clientY;
                    playerObj.rotation.y -= touchState.look.dx * CONFIG.turnSpeed;
                    camera.rotation.x = Math.max(-1, Math.min(1, camera.rotation.x - touchState.look.dy * CONFIG.turnSpeed));
                }
            }
        }, {passive: false});

        const reset = (e) => {
            for (const t of e.changedTouches) {
                if (t.identifier === touchState.move.id) { touchState.move.id = -1; touchState.move.dx = 0; touchState.move.dy = 0; }
                if (t.identifier === touchState.look.id) { touchState.look.id = -1; }
            }
        };
        cv.addEventListener('touchend', reset);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        // 移動
        if (touchState.move.id !== -1) {
            const dir = new THREE.Vector3(touchState.move.dx, 0, touchState.move.dy)
                .applyAxisAngle(new THREE.Vector3(0,1,0), playerObj.rotation.y);
            playerObj.position.addScaledVector(dir, CONFIG.speed * dt);
        }

        // 接地
        const ray = new THREE.Raycaster(new THREE.Vector3(playerObj.position.x, 200, playerObj.position.z), new THREE.Vector3(0, -1, 0));
        const hit = ray.intersectObject(ground);
        if (hit.length > 0) {
            playerObj.position.y = THREE.MathUtils.lerp(playerObj.position.y, hit[0].point.y, 0.1);
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
